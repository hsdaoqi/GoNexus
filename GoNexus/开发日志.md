## 准备阶段
### 文件目录
~~~ text
GoNexus/
├── cmd/                        # 项目的启动入口
│   └── server/
│       └── main.go             # 主程序：负责初始化资源、启动服务
│
├── api/                        # 协议定义文件
│   └── proto/                  # gRPC 的 .proto 文件 (用于和 Python 通信)
│       └── ai_service.proto
│
├── configs/                    # 配置文件模板
│   └── config.yaml             # 包含 DB, Redis, gRPC 地址, JWT 秘钥等
│
├── deploy/                     # 部署相关
│   ├── docker-compose.yaml     # 一键启动 MySQL+Redis+Go+Python
│   ├── Dockerfile
│   └── sql/                    # 数据库初始化 SQL 脚本
│
├── internal/                   # 【核心】私有应用代码 (Go 编译器强制只有本项目能引用)
│   ├── api/                    # 接口层 (Handler/Controller)
│   │   ├── v1/                 # 版本控制 (复试加分项)
│   │   │   ├── user.go         # 处理 /api/v1/user 相关的请求参数解析
│   │   │   └── chat.go         # 处理 HTTP 聊天历史记录请求
│   │   └── router.go           # Gin 路由注册中心
│   │
│   ├── core/                   # 核心业务组件
│   │   └── socket/             # WebSocket 核心引擎
│   │       ├── client.go       # 单个连接对象 (读写协程)
│   │       ├── hub.go          # 连接管理器 (广播、注册、注销)
│   │       └── message.go      # 消息协议定义
│   │
│   ├── service/                # 业务逻辑层 (Service) - 处理复杂逻辑
│   │   ├── user_service.go     # 登录逻辑、Token签发
│   │   ├── chat_service.go     # 消息落库、调用 AI
│   │   └── ai_service.go       # 封装 gRPC 调用，假装这是一个本地方法
│   │
│   ├── repository/             # 数据访问层 (DAO) - 只做 CRUD，不含业务逻辑
│   │   ├── user_repo.go        # GORM 操作 User 表
│   │   └── message_repo.go     # GORM 操作 Message 表
│   │
│   ├── model/                  # 数据库模型 (Struct)
│   │   ├── user.go
│   │   ├── message.go
│   │   └── migration.go        # 统一迁移入口
│   │
│   └── middleware/             # Gin 中间件
│       ├── cors.go             # 跨域处理
│       ├── jwt.go              # JWT 鉴权拦截器
│       └── logger.go           # 请求日志记录
│
├── pkg/                        # 【通用】公共库 (可以被其他项目引用的工具)
│   ├── global/                 # 全局变量 (DB 句柄, Redis 句柄, Config 对象)
│   ├── utils/                  # 工具箱
│   │   ├── upload/             # 文件上传工具
│   │   ├── md5.go              # 密码加密
│   │   └── jwt.go              # Token 生成与解析
│   │
│   └── response/               # 统一响应封装 (JSON Result)
│       ├── response.go         # 定义 {code, msg, data} 结构
│       └── errcode.go          # 定义业务错误码 (1001: 用户不存在)
│
├── go.mod                      # 依赖管理
└── Makefile                    # 项目管理脚本 (Build, Run, Proto生成) - 复试装逼利器
~~~
### 核心依赖包清单 (Go Modules)
1. Web 框架与基础\
   `github.com/gin-gonic/gin`\
   用途： Web 框架，处理 HTTP 请求、路由、中间件。\
   理由： Go 领域最流行，性能好，面试官都懂。
2. 数据库与缓存\
   `gorm.io/gorm` & `gorm.io/driver/mysql`\
   用途： ORM 框架，操作 MySQL。\
   `github.com/go-redis/redis/v8`\
   用途： 操作 Redis。\
   理由： 官方推荐库，支持连接池和集群。
3. WebSocket\
   `github.com/gorilla/websocket`\
   用途： 实现 WebSocket 协议升级和读写。\
   理由： 事实上的标准库，比 `golang.org/x/net/websocket` 更稳定。
4. 配置管理 (加分项)\
   `github.com/spf13/viper`\
   用途： 读取 config.yaml。\
   理由： 支持热加载配置，大厂标配。不要硬编码数据库密码在代码里！
5. 日志管理\
   `go.uber.org/zap`
   用途： 高性能日志库。\
   理由： 比标准库 log 快得多，支持结构化日志（JSON格式），适合搜日志。
6. 鉴权与工具\
   `github.com/golang-jwt/jwt/v4`\
   用途： 生成和校验 Token。\
   `github.com/satori/go.uuid`\
   用途： 生成唯一 ID (UUID)。
7. gRPC (连接 Python)\
   `google.golang.org/grpc`\
   `google.golang.org/protobuf`\
   用途： RPC 通信框架。


这是为您准备的 **Day 02 开发日志**。

这份日志不仅记录了代码，还重点梳理了**设计思路**和**面试考点**（比如为什么用 UUID，为什么用序列化）。你可以直接保存为 `DevLog_Day02.md`。

***


# GoNexus 开发日志 - Day 02：数据持久化与模型设计

**日期**：2025-12-12
**作者**：道柒
**进度**：🟢 数据库层建设完成

---

## 1. 今日目标
- [x] 实现配置文件的自动化读取 (Viper)。
- [x] 完成全局变量 (`global`) 的封装。
- [x] 初始化 GORM 并成功连接 MySQL。
- [x] 设计**工业级**的用户数据模型 (User Model)。
- [x] 验证 `AutoMigrate` 自动建表功能。

## 2. 核心技术实现

### 2.1 配置管理 (Configuration)
为了避免敏感信息（如数据库密码）硬编码在代码中，采用了 **Viper** 库进行配置管理。
*   **实现方式**：定义 `config.yaml`，通过结构体映射将 YAML 数据加载到内存。
*   **代码位置**：`pkg/initialize/viper.go`
*   **设计考量**：支持多环境配置（Debug/Release），符合 **Twelve-Factor App** 的配置原则。

### 2.2 数据库连接池 (GORM Connection)
在 `pkg/initialize/gorm.go` 中封装了 MySQL 的连接逻辑，并配置了连接池参数：
```go
sqlDB.SetMaxIdleConns(10)  // 最大空闲连接
sqlDB.SetMaxOpenConns(100) // 最大打开连接
sqlDB.SetConnMaxLifetime(time.Hour)
```
> **面试准备**：设置连接池是为了复用 TCP 连接，减少频繁握手带来的网络开销，这在高并发场景下至关重要。

### 2.3 用户模型设计 (User Model) —— *今日重点*
设计了一张不仅仅满足业务，且具备安全性和扩展性的 `users` 表。

**代码文件**：`internal/model/user.go`

| 关键字段/特性 | 类型 | 设计意图 (Design Rationale) |
| :--- | :--- | :--- |
| **UUID** | `char(36)` | **安全防爬**。对外接口暴露 UUID 而非自增 ID，防止攻击者遍历猜测用户数量。利用 GORM Hook 自动生成。 |
| **Tags** | `json` | **NoSQL 特性融合**。利用 GORM 的 `serializer:json`，将用户标签数组直接存为 JSON 字符串，避免了创建额外的关联表，减少 JOIN 查询。 |
| **Password** | `varchar(100)` | **预留哈希空间**。为后续接入 Bcrypt/Argon2 加密预留足够的字符长度。 |
| **DeletedAt** | `datetime` | **软删除**。数据是资产，软删除保证了数据的可恢复性和审计能力。 |

## 3. 遇到的难点与解决
*   **问题**：如何在 GORM 中优雅地存储 `[]string` 类型的数组？
*   **解决**：使用了 GORM 的 `serializer:json` 标签。
   *   *存库时*：自动序列化为 `["Go", "AI"]` 字符串。
   *   *读取时*：自动反序列化为 Go 切片。
   *   这大大简化了业务层代码，无需手动 `Marshal/Unmarshal`。

## 4. 验证结果
启动 `main.go` 后，控制台输出如下，且数据库中自动生成了 `users` 表及新增字段。

```text
✅ 配置文件读取成功
✅ MySQL 连接成功
[info] creating table `users` ...
✅ 数据库表结构迁移成功！
```

## 5. 明日计划
1.  **用户注册接口**：实现密码加密存储 (MD5/Bcrypt)。
2.  **JWT 鉴权**：签发 Token，实现无状态登录。
3.  **Swagger 文档**：集成接口文档，方便后续联调。

# GoNexus 开发日志 - Day 03：接口规范化与注册模块实现

**日期**：202X-XX-XX
**作者**：[你的名字]
**进度**：🟢 用户注册模块已上线 | ✅ 接口测试通过

---

## 1. 今日目标
- [x] 重构响应包 (`pkg/response`)，实现**统一的 JSON 响应格式**。
- [x] 定义**业务错误码** (`errcode.go`)，消除代码中的“魔法数字”。
- [x] 实现 **CORS 跨域中间件**，为前后端分离打通网络屏障。
- [x] 完成 **用户注册接口** (API -> Service -> Repository)。
- [x] 建立 **Postman 自动化测试集**，验证接口功能与健壮性。

## 2. 核心技术实现细节

### 2.1 统一响应规范 (Standardized Response)
为了解决 API 返回格式混乱的问题，封装了标准响应结构：
```go
type Response struct {
    Code int         `json:"code"` // 业务码 (非HTTP状态码)
    Msg  string      `json:"msg"`  // 提示信息
    Data interface{} `json:"data"` // 泛型数据
}
```
*   **设计亮点**：区分了 `Fail` (业务错误, HTTP 200) 和 `Error` (系统错误, HTTP 4xx/5xx)，增强了前端对异常处理的灵活性。

### 2.2 错误码管理 (Error Code Management)
在 `pkg/response/errcode.go` 中集中管理错误码：
*   **实践**：将 `400`、`500` 等硬编码替换为语义化的常量（如 `ErrUserExist = 2001`）。
*   **复试考点**：体现了代码的**高内聚**和**可维护性**，修改一处即可全局生效。


### 2.3 用户注册逻辑
采用 **ShouldBindJSON** 进行参数绑定与校验，配合 **Bcrypt** 进行密码加密。
*   **流程**：请求参数校验 -> 查重 -> 密码加盐哈希 -> 写入数据库。
*   **代码选择**：使用 `ShouldBindJSON` 而非 `BindJSON`，以便在参数错误时能返回自定义的 JSON 格式，而不是被框架强制中断。

## 3. 测试与验证 (Verification)

利用 Postman 建立了标准化的测试流程：

*   **测试环境**：Local (`localhost:8080`)
*   **测试接口**：`POST /api/v1/user/register`
*   **Body 类型**：`raw` (application/json)
*   **自动化断言 (Test Scripts)**：
    ```javascript
    pm.test("Business Code is 200", function () {
        pm.expect(pm.response.json().code).to.eql(200);
    });
    ```
*   **测试结果**：全绿 (PASS)，接口响应时间 < 200ms，功能符合预期。

## 4. 遇到的问题与解决
1.  **命名冲突**：
   *   *问题*：`response` 包中 `Success` 常量与 `Success` 函数名冲突。
   *   *解决*：将常量重命名为 `CodeSuccess`，保持函数名简洁，符合 Go 命名惯例。
2.  **中间件重复**：
   *   *问题*：`gin.Default()` 已包含 Logger/Recovery，后续代码重复 `Use` 导致日志双重打印。
   *   *解决*：移除了冗余的 `Use` 代码，优化了启动流程。

## 5. 明日计划 (Next Steps)
1.  **JWT 核心实现**：引入 `golang-jwt` 包，实现 Token 的签发 (Sign) 与解析 (Parse)。
2.  **用户登录接口**：验证密码，下发 Token。
3.  **鉴权中间件**：拦截非登录请求，解析 Token 中的 UserID。


# GoNexus 开发日志 - Day 04：JWT 身份认证与安全架构

**日期**：202X-XX-XX
**作者**：[你的名字]
**进度**：🟢 登录认证闭环 | ✅ 鉴权中间件上线 | ✅ 数据脱敏完成

---

## 1. 今日目标
- [x] 集成 `golang-jwt/jwt/v5`，实现 Token 的签发 (Sign)与解析 (Parse)。
- [x] 完成**用户登录业务**：密码校验 (Bcrypt) + Token 生成。
- [x] 开发 **JWT 鉴权中间件**：实现无状态的身份拦截与上下文传递。
- [x] 实现**用户信息接口**：采用 **DTO (Data Transfer Object)** 模式进行数据脱敏。
- [x] 验证**私有路由**机制：只有携带有效 Token 才能访问特定接口。

## 2. 核心技术架构 (Core Architecture)

### 2.1 JWT 无状态认证 (Stateless Authentication)
放弃了传统的 Session+Cookie 模式，采用 **JWT (JSON Web Token)** 方案。
*   **设计理由**：
   1.  **微服务适配**：Go 后端签发的 Token，Python AI 服务可直接校验，无需共享 Session 存储。
   2.  **高性能**：服务器不存储 Session 状态，极大降低内存压力，适合高并发场景。
*   **安全配置**：
   *   Secret (秘钥) 与 Expire (过期时间) 通过配置文件 (`config.yaml`) 管理，严禁硬编码。
   *   Payload 中只存储非敏感数据 (`user_id`, `username`)，**绝不存储密码**。

### 2.2 鉴权中间件 (Auth Middleware)
实现了基于 Gin 的拦截器 `middleware.Auth()`。
*   **工作流**：拦截请求 -> 校验 `Authorization` 头 -> 解析 Token -> 注入上下文 (`c.Set`)。
*   **上下文传递**：
    ```go
    // 中间件存入
    c.Set("userID", claims.UserID)
    
    // Controller 取出
    userID, _ := c.Get("userID")
    ```
    > **架构思考**：利用 Gin 的 `Context` 实现跨层数据传递，保证了链路中用户身份的一致性。

### 2.3 数据传输对象 (DTO Pattern)
在 `GetUserInfo` 接口中，严格分离了 **Model (数据库模型)** 和 **View (视图模型)**。
*   **问题**：直接返回 `model.User` 会暴露 `Password` (加密串)、`DeletedAt` 等敏感或无用字段。
*   **解决**：定义 `UserProfileResponse` 结构体，只从 Service 层返回前端需要的清洗后的数据。
    ```go
    type UserProfileResponse struct {
        ID        uint     `json:"id"`
        Username  string   `json:"username"`
        Tags      []string `json:"tags"` // JSON 序列化字段
        // ... 不包含 Password
    }
    ```

## 3. 测试验证 (Testing)

利用 Postman 进行了完整的身份闭环测试：

1.  **登录 (Login)**：
   *   输入：`username`, `password`
   *   输出：`token` (JWT字符串)
2.  **未授权访问 (Unauthorized)**：
   *   不带 Token 访问 `/api/v1/user/info`
   *   结果：`401 Unauthorized`，msg: "未登录或非法访问" (中间件拦截成功)。
3.  **授权访问 (Authorized)**：
   *   Header 添加 `Authorization: Bearer <token>`
   *   结果：`200 OK`，返回不含密码的用户详细信息。

## 4. 遇到的问题与解决
*   **问题**：在 Controller 中直接查询数据库导致代码耦合度过高。
*   **解决**：严格遵守分层架构。
   *   **Repository**: 负责 SQL (`First`, `Find`)。
   *   **Service**: 负责 DTO 转换和业务逻辑。
   *   **Controller**: 只负责参数绑定和响应。

## 5. 明日计划 (Next Steps)
核心地基已搭建完毕，即将进入社交系统的最复杂部分：**好友关系管理**。
1.  **好友表设计**：设计支持双向关系的数据库表结构 (Friendship)。
2.  **好友申请**：申请、通过、拒绝的业务逻辑状态机。
3.  **列表查询**：查询我的好友列表 (复杂的 JOIN 或关联查询)。


# GoNexus 开发日志 - Day 05：好友关系管理系统实现

**日期**：2025-12-16
**作者**：道柒
**进度**：🟢 好友功能开发完成 | ✅ 问题修复完成

---

## 1. 今日目标
- [x] 完成好友关系数据模型设计 (Friend Model)
- [x] 实现好友申请发送接口 (SendFriendRequest)
- [x] 实现好友申请处理接口 (HandleFriendRequest)
- [x] 实现好友列表获取接口 (GetFriendList)
- [x] 实现好友删除接口 (DeleteFriendRecord)
- [x] 优化数据库操作，避免数据堆积问题
- [x] 修复软删除相关的业务逻辑错误

## 2. 核心技术实现

### 2.1 数据模型设计

**好友关系模型 (Friend)**：
```go
type Friend struct {
	gorm.Model
	UserID     uint   `json:"user_id" gorm:"index:idx_user_friend,unique:idx_user_friend"`
	FriendID   uint   `json:"friend_id" gorm:"index:idx_user_friend,unique:idx_user_friend"`
	Source     int    `json:"source"`
	DeletedAt  gorm.DeletedAt `json:"deleted_at" gorm:"index"`
}
```

**好友申请模型 (FriendRequest)**：
```go
type FriendRequest struct {
	gorm.Model
	RequesterID uint   `json:"requester_id" gorm:"index"`
	ReceiverID  uint   `json:"receiver_id" gorm:"index"`
	VerifyMsg   string `json:"verify_msg" gorm:"type:varchar(200)"`
	Status      int    `json:"status" gorm:"index"`
}
```

### 2.2 核心功能实现

#### 2.2.1 好友申请发送
**代码位置**：`internal/service/friend_service.go`
- 实现了发送好友申请的业务逻辑，包括：
  - 参数校验
  - 重复申请检查
  - 入库操作

#### 2.2.2 好友申请处理
**代码位置**：`internal/service/friend_service.go`
- 实现了处理好友申请的核心逻辑，包括：
  - 权限校验（确保申请是发给自己的）
  - 状态校验（必须是待处理状态）
  - 拒绝申请时直接删除记录（避免数据库堆积）
  - 同意申请时的双向好友关系创建/恢复

#### 2.2.3 好友列表获取
**代码位置**：`internal/repository/friend_repo.go`
- 实现了高效的好友列表查询，包括：
  - 关联用户表查询好友详细信息
  - 过滤已软删除的好友关系

#### 2.2.4 好友删除功能
**代码位置**：`internal/service/friend_service.go`
- 实现了双向软删除好友关系的功能，确保数据一致性

## 3. 问题修复与优化

### 3.1 数据库堆积问题修复
**问题**：拒绝好友申请时仅更新状态而不删除记录，导致数据库堆积大量关系数据
**解决方案**：修改服务层代码，将拒绝申请时的状态更新改为直接删除记录
```go
// 如果是拒绝，直接删除记录，避免数据库堆积
if action == model.RequestStatusRefused {
    return global.DB.Delete(req).Error
}
```

### 3.2 软删除记录恢复问题
**问题**：删除好友后重新发送申请并同意时出现唯一键冲突
**解决方案**：在同意申请时先检查是否存在已删除记录，若存在则恢复而非创建新记录
```go
// 使用Unscoped()包含软删除记录
result := tx.Unscoped().Where("user_id = ? AND friend_id = ?", req.ReceiverID, req.RequesterID).First(&friendA)
if result.Error != nil {
    if errors.Is(result.Error, gorm.ErrRecordNotFound) {
        // 不存在记录，创建新记录
        friendA = model.Friend{...}
        if err := tx.Create(&friendA).Error; err != nil {
            return err
        }
    } else {
        return result.Error
    }
} else {
    // 记录存在，恢复软删除
    if err := tx.Unscoped().Model(&friendA).Update("deleted_at", nil).Error; err != nil {
        return err
    }
}
```

### 3.3 查询条件错误修复
**问题**：GetPendingRequest函数使用错误的查询条件（requester_id而非id）
**解决方案**：修正查询条件，确保通过申请记录ID查询
```go
err := global.DB.Where("id = ? AND status = ?", requestID, model.RequestStatusPending).First(&req).Error
```

### 3.4 软删除过滤问题
**问题**：获取好友列表时未过滤已软删除的记录
**解决方案**：在查询好友列表时添加软删除过滤条件
```go
err = global.DB.Table("users").Select("users.id, users.username, users.avatar, users.tags, users.gender").
    Joins("JOIN friends ON users.id = friends.friend_id").
    Where("friends.user_id = ? AND friends.deleted_at IS NULL", userID).
    Scan(&result).Error
```

## 4. 测试验证

通过Postman进行了完整的好友功能测试：

1. **发送好友申请**：
   - 接口：`POST /api/v1/friend/request`
   - 结果：申请成功创建，状态为待处理

2. **处理好友申请**：
   - 同意：`POST /api/v1/friend/handle` (action: 1)
   - 拒绝：`POST /api/v1/friend/handle` (action: 2)
   - 结果：同意后创建双向好友关系，拒绝后删除申请记录

3. **获取好友列表**：
   - 接口：`GET /api/v1/friend/list`
   - 结果：正确返回好友列表，不包含已删除好友

4. **删除好友**：
   - 接口：`POST /api/v1/friend/delete`
   - 结果：软删除双向好友关系，从列表中移除

5. **重新添加好友**：
   - 流程：删除好友 → 重新发送申请 → 同意
   - 结果：成功恢复好友关系，无唯一键冲突

## 5. 明日计划

1. **聊天功能实现**：开发WebSocket实时聊天功能
2. **消息历史记录**：实现聊天记录的持久化和查询
3. **群聊功能**：扩展好友功能，实现群聊支持
4. **性能优化**：对高频接口进行性能调优和缓存设计

这是为您补充的 **Day 06** 和 **Day 07** 开发日志。

这两天的内容涵盖了**即时通讯（IM）核心**的构建、**设计模式重构**以及**AI 微服务（RAG）**的深度集成。这些是整个毕设中最具含金量的部分，建议重点保留。

您可以将以下内容追加到您的 `.md` 文件末尾：

***

# GoNexus 开发日志 - Day 06：IM 核心与架构重构

**日期**：2025-12-17
**作者**：道柒
**进度**：🟢 WebSocket 通讯闭环 | 🟢 策略模式重构 | ✅ 消息持久化

---

## 1. 今日目标
- [x] 基于 `gorilla/websocket` 实现全双工通信核心 (Manager/Client)。
- [x] 实现 **心跳机制 (Heartbeat)**，自动清理僵尸连接。
- [x] 完成 **PO (持久化对象)** 与 **DTO (传输对象)** 的架构分离。
- [x] 利用 **策略模式 (Strategy Pattern)** 重构消息处理逻辑。
- [x] 实现单聊 (Private Chat) 与群聊 (Group Chat) 的写扩散逻辑。
- [x] 开发历史消息查询接口 (Pagination)。

## 2. 核心技术架构

### 2.1 WebSocket 核心引擎
采用 **Manager-Client** 模型管理海量连接：
*   **Manager (Hub)**：全局单例，维护 `map[userID]*Client`，负责广播和点对点路由。使用 `RWMutex` 读写锁保障并发安全。
*   **Client**：每个连接启动两个 Goroutine (`ReadPump`/`WritePump`) 实现读写分离，避免阻塞。
*   **优化点**：在 `WritePump` 中实现了**缓冲写入**，合并多个小包为一个 TCP 包发送，降低 syscall 开销。

### 2.2 架构重构：PO/DTO 分离
为了解决数据库模型与前端协议不一致的问题，进行了分层设计：
*   **PO (`internal/model/message.go`)**：对应数据库 `messages` 表，仅存储核心数据 (`Content`, `FromID`, `ToID`)。
*   **DTO (`internal/model/dto/protocol.go`)**：定义 WebSocket 传输协议，包含冗余展示字段 (`SenderAvatar`, `SenderNickname`)，避免前端 N+1 次查询。

### 2.3 设计模式：策略模式 + 工厂模式
针对不同类型的消息（单聊、群聊、系统通知），摒弃了冗长的 `switch-case`，改为接口多态实现：
*   **接口定义**：`handler.MsgHandler`
*   **策略实现**：`PrivateHandler` (单聊), `GroupHandler` (群聊写扩散)。
*   **分发逻辑**：在 `Client` 中维护 `map[int]MsgHandler` 路由表，符合**开闭原则 (Open-Closed Principle)**，易于扩展。

## 3. 测试与验证
利用 Postman 进行双客户端在线联调：
1.  **单聊测试**：Alice 发送消息给 Bob，Bob 实时收到推送，且 MySQL 中生成记录。
2.  **群聊测试**：群成员 A 发送消息，群成员 B、C 同时收到推送。
3.  **心跳测试**：客户端断网 60s 后，服务端自动注销连接并释放资源。

## 4. 遇到的问题与解决
*   **问题**：Go 包循环引用 (Import Cycle)。`socket` 包引用 `service`，而 `service` 又引用 `socket` 中的协议定义。
*   **解决**：提取公共依赖。将协议结构体移至独立的 `internal/model/dto` 包中，打破依赖环。

---

# GoNexus 开发日志 - Day 07：AI 微服务与 RAG 闭环

**日期**：2025-12-18
**作者**：道柒
**进度**：🟢 Python 微服务上线 | 🟢 gRPC 通信打通 | ✅ RAG 智能问答闭环

---

## 1. 今日目标
- [x] 搭建 **Python AI 微服务** (FastAPI + gRPC)。
- [x] 定义跨语言通信标准 `.proto` 文件并生成代码。
- [x] 集成 **ChromaDB** 向量数据库与 **DeepSeek/OpenAI** 大模型。
- [x] 实现 **RAG (检索增强生成)** 核心引擎：记忆存储与语义搜索。
- [x] 打通 **Go -> Python** 的双向链路：实时聊天数据自动同步给 AI。

## 2. 核心技术实现

### 2.1 微服务架构 (Microservices)
系统拆分为两个独立服务，通过 **gRPC** 进行高性能通信：
*   **GoNexus (Go)**：负责 IM 业务、WebSocket 连接、MySQL 存储。
*   **GoNexus-AI (Python)**：负责向量计算、LLM 交互、ChromaDB 存储。
*   **通信协议**：使用 **Protobuf** 定义了 `SyncMessage` (同步), `SemanticSearch` (搜索), `ChatSummary` (总结) 三大接口。

### 2.2 RAG 引擎 (Retrieval-Augmented Generation)
Python 端封装了 `RAGEngine` 类：
1.  **Embedding**：使用 `SentenceTransformer` 或 OpenAI Embedding 将聊天文本向量化。
2.  **Vector Store**：使用 **ChromaDB** 持久化存储向量数据。
3.  **LLM Generation**：检索 Top-K 相关历史记录，注入 Prompt Context，由大模型生成回答。
    *   *优化*：修复了检索结果丢失元数据的问题，现在 Prompt 包含“Who said What”，AI 能准确区分发言人。

### 2.3 异步数据流 (Async Data Flow)
为了不影响聊天延迟，设计了异步投喂机制：
*   **流程**：用户发送 WebSocket 消息 -> Go `ReadPump` -> `go core.AsyncSyncMessage()` (协程异步) -> gRPC -> Python -> ChromaDB。
*   **效果**：聊天即时响应，同时 AI 在后台静默学习。

## 3. 测试与验证
全链路闭环测试：
1.  **记忆阶段**：在聊天室发送“下周一早上9点开会”。 -> 查看 Python 日志显示 `[同步成功]`。
2.  **问答阶段**：调用 HTTP 接口 `GET /api/v1/ai/search?query=什么时候开会`。
3.  **结果**：接口返回 `{"answer": "根据记录，开会时间是下周一早上9点。"}`。 -> **RAG 验证成功**。

## 4. 遇到的问题与解决
*   **问题**：`protoc` 生成代码时出现路径嵌套 (`internal/api/proto/internal/...`)。
*   **解决**：修正 `protoc` 命令的输出路径参数为当前目录 `.`，配合 `source_relative` 选项解决。
*   **问题**：DeepSeek API 报错 `402 Insufficient Balance`。
*   **解决**：充值 API 额度并重新配置 `.env` 文件。

## 5. 后续计划
后端核心架构已全部完成。接下来的重点转向**前端可视化**：
1.  搭建 Vue 3 + TypeScript + Element Plus 项目。
2.  实现登录/注册页面对接。
3.  开发 Web 版聊天界面，展示 IM 和 AI 功能。

---

# GoNexus 开发日志 - Day 08：前端项目搭建与基础架构

**日期**：2025-01-01
**作者**：道柒
**进度**：🟢 前端项目初始化 | 🟢 技术栈选型完成 | ✅ 开发环境搭建

---

## 1. 今日目标
- [x] 搭建 Vue 3 + TypeScript + Vite 项目结构
- [x] 配置 Element Plus UI 框架和相关插件
- [x] 实现项目目录结构和路由配置
- [x] 配置 Axios 请求封装和环境变量
- [x] 创建基础的登录注册页面

## 2. 技术栈选型

### 2.1 前端框架
- **Vue 3**：使用 Composition API，提供更好的 TypeScript 支持
- **TypeScript**：提供类型安全，提高代码质量和开发效率
- **Vite**：快速的构建工具，支持热重载和ESM模块化

### 2.2 UI框架和工具库
- **Element Plus**：Vue 3版本的Element UI，组件丰富，设计统一
- **Vue Router 4**：官方路由管理器
- **Pinia**：Vue 3官方状态管理库（替代Vuex）
- **Axios**：HTTP请求库，支持请求拦截器和响应拦截器

### 2.3 样式和动画
- **SCSS/Sass**：CSS预处理器，支持变量、嵌套、混入等特性
- **vue-particles**：粒子背景效果库，用于打造科技感界面

## 3. 项目结构设计

```
GoNexus-Web/
├── src/
│   ├── api/                 # API接口封装
│   │   ├── auth.ts         # 认证相关接口
│   │   ├── chat.ts         # 聊天相关接口
│   │   └── user.ts         # 用户相关接口
│   ├── assets/             # 静态资源
│   ├── components/         # 公共组件
│   ├── router/             # 路由配置
│   ├── store/              # 状态管理
│   ├── utils/              # 工具函数
│   ├── views/              # 页面组件
│   │   ├── auth/           # 认证页面
│   │   ├── chat/           # 聊天页面
│   │   ├── home/           # 首页
│   │   └── profile/        # 个人资料
│   └── types/              # TypeScript类型定义
├── public/                 # 公共静态资源
├── env.d.ts               # 环境变量类型定义
├── index.html             # HTML模板
├── package.json           # 项目配置和依赖
├── tsconfig.json          # TypeScript配置
└── vite.config.ts         # Vite构建配置
```

## 4. 核心功能实现

### 4.1 请求封装 (Axios Interceptors)
```typescript
// src/utils/request.ts
import axios from 'axios'
import { ElMessage } from 'element-plus'

const request = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL,
  timeout: 10000
})

// 请求拦截器
request.interceptors.request.use(
  config => {
    const token = localStorage.getItem('token')
    if (token) {
      config.headers.Authorization = `Bearer ${token}`
    }
    return config
  },
  error => Promise.reject(error)
)

// 响应拦截器
request.interceptors.response.use(
  response => response.data,
  error => {
    ElMessage.error(error.response?.data?.message || '请求失败')
    return Promise.reject(error)
  }
)

export default request
```

### 4.2 状态管理 (Pinia)
```typescript
// src/store/user.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'

export const useUserStore = defineStore('user', () => {
  const userInfo = ref<UserInfo | null>(null)
  const token = ref<string>('')

  const isLoggedIn = computed(() => !!token.value)

  const setUserInfo = (info: UserInfo) => {
    userInfo.value = info
  }

  const setToken = (newToken: string) => {
    token.value = newToken
    localStorage.setItem('token', newToken)
  }

  const logout = () => {
    userInfo.value = null
    token.value = ''
    localStorage.removeItem('token')
  }

  return {
    userInfo,
    token,
    isLoggedIn,
    setUserInfo,
    setToken,
    logout
  }
})
```

### 4.3 路由配置
```typescript
// src/router/index.ts
import { createRouter, createWebHistory } from 'vue-router'

const routes = [
  {
    path: '/login',
    name: 'Login',
    component: () => import('../views/auth/Login.vue'),
    meta: { requiresAuth: false }
  },
  {
    path: '/register',
    name: 'Register',
    component: () => import('../views/auth/Register.vue'),
    meta: { requiresAuth: false }
  },
  {
    path: '/',
    name: 'Home',
    component: () => import('../views/Home.vue'),
    meta: { requiresAuth: true }
  },
  {
    path: '/chat',
    name: 'Chat',
    component: () => import('../views/chat/Index.vue'),
    meta: { requiresAuth: true }
  },
  {
    path: '/profile',
    name: 'Profile',
    component: () => import('../views/profile/Index.vue'),
    meta: { requiresAuth: true }
  }
]

const router = createRouter({
  history: createWebHistory(),
  routes
})

// 路由守卫
router.beforeEach((to, from, next) => {
  const token = localStorage.getItem('token')
  const requiresAuth = to.meta.requiresAuth

  if (requiresAuth && !token) {
    next('/login')
  } else if (!requiresAuth && token && to.path !== '/profile') {
    next('/')
  } else {
    next()
  }
})

export default router
```

## 5. SAO风格界面设计

### 5.1 设计理念
受《刀剑神域》启发，打造具有科技感和未来感的界面：
- **粒子背景**：使用vue-particles创建动态粒子效果
- **毛玻璃效果**：backdrop-filter: blur() 实现现代感
- **蓝色渐变**：使用#4facfe到#00f2fe的渐变色
- **科幻字体**：Orbitron字体营造科技氛围

### 5.2 核心样式变量
```scss
// src/styles/variables.scss
:root {
  --primary-color: #4facfe;
  --secondary-color: #00f2fe;
  --background-dark: #0a0a0a;
  --text-primary: #ffffff;
  --text-secondary: #b0b0b0;
  --glass-bg: rgba(255, 255, 255, 0.1);
  --glass-border: rgba(255, 255, 255, 0.2);
}
```

## 6. 遇到的问题与解决

### 6.1 Vue 3 Composition API 学习曲线
**问题**：从Vue 2迁移到Vue 3，需要重新学习Composition API
**解决**：
- 使用`<script setup>`语法糖简化代码
- 掌握reactive、ref、computed等响应式API
- 学习生命周期钩子的变化

### 6.2 TypeScript类型定义
**问题**：需要为所有API响应和组件props定义类型
**解决**：
- 创建types目录存放全局类型定义
- 使用interface定义API响应结构
- 为组件props添加类型注解

### 6.3 跨域问题
**问题**：开发时前端和后端端口不同导致跨域
**解决**：
- 配置Vite代理：`vite.config.ts`
- 设置`server.proxy`将API请求转发到后端

## 7. 明日计划
1. **登录注册页面开发**：实现表单验证和API对接
2. **WebSocket客户端集成**：连接实时聊天功能
3. **聊天界面开发**：实现消息发送和接收
4. **个人资料页面**：完善用户信息管理

---

# GoNexus 开发日志 - Day 09：登录注册与认证流程

**日期**：2025-01-02
**作者**：道柒
**进度**：🟢 登录注册页面完成 | 🟢 表单验证实现 | ✅ API对接成功

---

## 1. 今日目标
- [x] 实现登录页面UI设计和表单验证
- [x] 实现注册页面UI设计和密码确认验证
- [x] 完成登录注册API接口对接
- [x] 实现JWT Token存储和管理
- [x] 配置路由守卫和自动登录

## 2. 登录页面实现

采用SAO风格设计，集成粒子背景效果和结衣精灵角色引导。使用Element Plus组件库实现表单验证和响应式布局。核心功能包括：

- **表单验证**：用户名和密码的必填及格式校验
- **API集成**：与后端JWT认证接口对接
- **状态管理**：登录成功后保存Token并更新用户状态
- **路由导航**：登录成功后自动跳转到首页

## 3. 注册页面实现

实现密码确认验证和邮箱格式校验，与后端注册接口对接。包含用户名长度限制和密码强度要求。

## 4. 认证流程优化

实现Token管理和自动登录功能。采用localStorage存储JWT Token，通过路由守卫实现页面访问控制。

## 5. 遇到的问题与解决

### 5.1 路由循环重定向
**问题**：登录后跳转到首页，首页又重定向到登录页
**解决**：修改路由守卫逻辑，避免已登录用户访问登录页时的无限循环

### 5.2 表单验证时机
**问题**：用户输入时实时验证影响体验
**解决**：将验证触发器设置为'blur'，仅在失去焦点时验证

### 5.3 Token过期处理
**问题**：Token过期后用户无感知
**解决**：在响应拦截器中检查401状态码，自动跳转到登录页

## 6. 明日计划
1. **聊天界面开发**：实现WebSocket连接和消息收发
2. **好友列表**：显示好友列表和在线状态
3. **消息历史**：实现聊天记录分页加载
4. **个人资料**：完善用户信息编辑功能

---

# GoNexus 开发日志 - Day 10：聊天界面与WebSocket集成

**日期**：2025-01-03
**作者**：道柒
**进度**：🟢 聊天界面完成 | 🟢 WebSocket连接成功 | ✅ 实时消息收发

---

## 1. 今日目标
- [x] 实现聊天主界面布局和样式
- [x] 集成WebSocket客户端连接
- [x] 实现消息发送和接收功能
- [x] 添加消息历史记录加载
- [x] 实现好友列表侧边栏

## 2. WebSocket客户端实现

实现WebSocket连接管理、心跳机制和自动重连。采用Pinia状态管理消息数据，支持实时消息收发和历史记录加载。

## 3. 聊天界面实现

采用左右分栏布局，左侧好友列表，右侧聊天区域。实现消息实时收发、历史记录加载和响应式布局适配。

## 4. 响应式布局优化

### 4.1 移动端适配
```scss
@media (max-width: 768px) {
  .chat-container {
    flex-direction: column;
  }

  .sidebar {
    width: 100%;
    height: 200px;
    border-right: none;
    border-bottom: 1px solid #e0e0e0;
  }

  .chat-area {
    height: calc(100vh - 200px);
  }

  .message-input {
    padding: 10px;
  }
}
```

## 5. 遇到的问题与解决

### 5.1 WebSocket重连机制
**问题**：网络不稳定时连接断开后无法自动重连
**解决**：实现指数退避重连算法，避免频繁重连导致服务器压力

### 5.2 消息顺序问题
**问题**：WebSocket消息和HTTP请求可能导致消息顺序错乱
**解决**：为每条消息添加时间戳，使用乐观更新确保用户体验

### 5.3 内存泄漏
**问题**：长时间聊天会导致消息列表无限增长
**解决**：实现消息分页加载，只保留最近的N条消息在内存中

## 6. 明日计划
1. **个人资料页面**：实现用户信息查看和编辑
2. **文件上传功能**：集成图片和文件发送
3. **AI聊天功能**：对接后端AI服务
4. **消息搜索**：实现聊天记录搜索功能

---

# GoNexus 开发日志 - Day 11：个人资料页面与文件上传

**日期**：2025-01-04
**作者**：道柒
**进度**：🟢 个人资料页面完成 | 🟢 文件上传实现 | ✅ 用户信息管理

---

## 1. 今日目标
- [x] 实现个人资料页面布局和样式
- [x] 完成用户信息查看和编辑功能
- [x] 集成头像上传功能
- [x] 实现隐私设置管理
- [x] 添加文件上传组件

## 2. 个人资料页面实现

采用标签页布局，包含基本信息、账号设置和隐私设置三个模块。实现头像上传、资料编辑和隐私控制功能。

## 3. 文件上传组件

### 3. 文件上传功能

封装文件上传API接口，支持单文件和多文件上传。实现拖拽上传、进度显示和文件预览功能。

## 4. 遇到的问题与解决

### 4.1 文件上传进度显示
**问题**：用户无法看到上传进度，体验不佳
**解决**：使用axios的onUploadProgress回调，实时更新进度条

### 4.2 文件类型校验
**问题**：前端校验可以被绕过
**解决**：前后端都进行文件类型和大小校验，后端校验作为最后防线

### 4.3 大文件上传优化
**问题**：大文件上传可能导致页面卡顿
**解决**：实现分片上传，将大文件分割成小块依次上传

